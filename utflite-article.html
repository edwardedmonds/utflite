<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>utflite: A Minimal UTF-8 Library for C</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 18px;
        }

        body {
            font-family: Georgia, 'Times New Roman', serif;
            line-height: 1.8;
            color: #2c2c2c;
            background-color: #fafaf8;
            padding: 2rem 1.5rem 4rem;
        }

        article {
            max-width: 38rem;
            margin: 0 auto;
        }

        header {
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #ddd;
        }

        h1 {
            font-size: 2rem;
            font-weight: normal;
            letter-spacing: -0.02em;
            color: #1a1a1a;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-style: italic;
            color: #666;
            font-size: 1.1rem;
        }

        .byline {
            font-size: 0.9rem;
            color: #888;
            margin-top: 0.75rem;
        }

        p {
            margin-bottom: 1.5rem;
            text-align: justify;
            hyphens: auto;
        }

        p:last-of-type {
            margin-bottom: 0;
        }

        .drop-cap::first-letter {
            float: left;
            font-size: 3.5rem;
            line-height: 0.8;
            padding-right: 0.5rem;
            padding-top: 0.2rem;
            color: #1a1a1a;
        }

        h2 {
            font-size: 1.3rem;
            font-weight: normal;
            color: #1a1a1a;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            font-style: italic;
        }

        code {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.85rem;
            background-color: #f0f0ee;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
        }

        pre {
            background-color: #2c2c2c;
            color: #e8e8e8;
            padding: 1.25rem;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 1.5rem;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
        }

        pre code {
            background: none;
            padding: 0;
            font-size: inherit;
        }

        a {
            color: #4a6fa5;
            text-decoration: none;
            border-bottom: 1px solid #c5d4e8;
        }

        a:hover {
            color: #2c4a7c;
            border-bottom-color: #4a6fa5;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            font-weight: normal;
            font-style: italic;
            color: #666;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .pros-cons > div {
            padding: 1rem;
            background: #f5f5f3;
            border-radius: 4px;
        }

        .pros-cons h3 {
            font-size: 1rem;
            font-weight: normal;
            font-style: italic;
            margin-bottom: 0.75rem;
            color: #1a1a1a;
        }

        .pros-cons ul {
            margin-left: 1.25rem;
            font-size: 0.9rem;
        }

        .pros-cons li {
            margin-bottom: 0.4rem;
        }

        footer {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #ddd;
            font-size: 0.85rem;
            color: #888;
            text-align: center;
        }

        footer a {
            color: #888;
            border-bottom-color: #ccc;
        }

        @media (max-width: 600px) {
            html {
                font-size: 16px;
            }

            body {
                padding: 1.5rem 1rem 3rem;
            }

            h1 {
                font-size: 1.6rem;
            }

            p {
                text-align: left;
                hyphens: none;
            }

            pre {
                font-size: 0.75rem;
                padding: 1rem;
            }

            .pros-cons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <article>
        <header>
            <h1>utflite</h1>
            <p class="subtitle">A minimal UTF-8 library for C</p>
            <p class="byline">by Edward J. Edmonds ¬∑ December 26, 2025</p>
        </header>

        <p class="drop-cap">Unicode handling in C has always been a compromise. On one side sits ICU, the 30-megabyte behemoth that handles every script and locale on Earth. On the other, you can roll your own UTF-8 decoder and hope you got the edge cases right. For many projects‚Äîterminal emulators, text editors, embedded systems‚Äîneither option feels quite right. You need correct UTF-8 handling and accurate character widths, but you don't need collation tables for Tibetan. That's the gap utflite aims to fill.</p>

        <p>utflite is a single-header UTF-8 library weighing in at under 40KB. It handles encoding, decoding, validation, and‚Äîcrucially‚Äîcharacter width calculation for terminal display. Drop one file into your project, add two lines of code, and you have Unicode 17.0 compliant text handling with zero external dependencies.</p>

        <h2>What It Does</h2>

        <p>The library provides the primitives you need to work with UTF-8 text correctly. <code>utflite_decode()</code> converts a byte sequence to a Unicode codepoint, handling malformed input gracefully by returning the replacement character. <code>utflite_encode()</code> goes the other direction. Navigation functions let you step forward and backward through strings by character rather than by byte.</p>

        <p>The real value, though, is in width calculation. Anyone who has tried to align columns in a terminal knows the pain: ASCII characters take one cell, CJK ideographs take two, combining marks take zero, and emoji... well, emoji are complicated. utflite includes Unicode 17.0 width tables that handle all of this:</p>

        <pre><code>int width = utflite_string_width("Hello‰∏≠Êñáüéâ", 17);  // Returns 12
// H(1) + e(1) + l(1) + l(1) + o(1) + ‰∏≠(2) + Êñá(2) + üéâ(2) = 12 columns</code></pre>

        <p>This is the function you reach for when you need to truncate a status line, align a tree view, or calculate how far to move the cursor. It correctly identifies zero-width characters like combining diacritical marks and ZWJ sequences, double-width characters like CJK and fullwidth forms, and everything in between.</p>

        <h2>The Alternatives</h2>

        <p>utflite occupies a specific niche. To understand when it makes sense, it helps to see what else is available.</p>

        <table>
            <tr>
                <th>Library</th>
                <th>Size</th>
                <th>Focus</th>
            </tr>
            <tr>
                <td>ICU</td>
                <td>~30 MB</td>
                <td>Everything: collation, normalization, locales, calendars</td>
            </tr>
            <tr>
                <td>libunistring</td>
                <td>~2 MB</td>
                <td>String operations, normalization, case mapping</td>
            </tr>
            <tr>
                <td>utf8proc</td>
                <td>~500 KB</td>
                <td>Normalization, case folding, grapheme clustering</td>
            </tr>
            <tr>
                <td>wcwidth()</td>
                <td>System</td>
                <td>Character width (often outdated)</td>
            </tr>
            <tr>
                <td>utflite</td>
                <td>~40 KB</td>
                <td>Encoding, width, validation</td>
            </tr>
        </table>

        <p><strong>ICU</strong> is the standard answer when someone asks about Unicode in C. It handles everything‚Äînormalization, collation, bidirectional text, date formatting, transliteration‚Äîwith meticulous correctness. The cost is size and complexity. ICU adds tens of megabytes to your binary and introduces a substantial build dependency. For a desktop application or web server, this is often acceptable. For a firmware project or a tool that should compile anywhere with just <code>make</code>, it's prohibitive.</p>

        <p><strong>libunistring</strong> and <strong>utf8proc</strong> sit in the middle ground. They provide normalization (NFC, NFD) and proper grapheme cluster handling, which utflite lacks. If you're processing user input where <code>√©</code> might arrive as either a single codepoint or a base letter plus combining accent, you need normalization. If you're building a text editor where the cursor must move by grapheme rather than codepoint (so an emoji with a skin tone modifier acts as one unit), you need proper segmentation. These libraries deliver that, at the cost of larger data tables and more complex integration.</p>

        <p><strong>wcwidth()</strong> from the system C library is what most developers reach for first‚Äîand what utflite often replaces. The problem is that system wcwidth implementations vary widely and are frequently outdated. A modern emoji that should render as double-width might return -1 or 1 depending on your libc version and locale settings. utflite bundles its own Unicode 17.0 tables, ensuring consistent behavior across platforms.</p>

        <h2>Honest Assessment</h2>

        <div class="pros-cons">
            <div>
                <h3>Strengths</h3>
                <ul>
                    <li>Single header, zero dependencies</li>
                    <li>Compiles anywhere with a C17 compiler</li>
                    <li>No heap allocation</li>
                    <li>Current Unicode 17.0 width tables</li>
                    <li>Handles malformed input gracefully</li>
                    <li>Small enough to audit in an afternoon</li>
                </ul>
            </div>
            <div>
                <h3>Limitations</h3>
                <ul>
                    <li>No normalization (NFC/NFD)</li>
                    <li>No grapheme cluster segmentation</li>
                    <li>No case mapping or folding</li>
                    <li>No bidirectional text support</li>
                    <li>No locale awareness</li>
                    <li>Width tables need manual updates for new Unicode versions</li>
                </ul>
            </div>
        </div>

        <p>The limitations matter. If you're building a text editor, the lack of grapheme clustering means your cursor will stop in the middle of emoji sequences. If you're comparing user-supplied strings, the lack of normalization means "caf√©" typed two different ways won't match. If you're handling Arabic or Hebrew, the lack of bidirectional support is a non-starter. For these cases, reach for utf8proc or ICU.</p>

        <h2>When to Use It</h2>

        <p>utflite makes sense for terminal applications, CLI tools, and embedded systems where you need correct width calculation without heavyweight dependencies. Specific use cases include:</p>

        <p><strong>Terminal UIs.</strong> Progress bars, status lines, tree views, and tables all need accurate column counting. utflite's <code>utflite_string_width()</code> and <code>utflite_truncate()</code> handle mixed ASCII/CJK/emoji text correctly, letting you align columns and truncate at character boundaries.</p>

        <p><strong>Text processing tools.</strong> If you're building something like <code>grep</code> or <code>wc</code> that needs to count characters rather than bytes, validate UTF-8 input, or iterate by codepoint, utflite provides the primitives without the weight of a full Unicode library.</p>

        <p><strong>Embedded systems.</strong> When you're working with limited flash and RAM, a 40KB single-header library that needs no heap allocation is far more practical than linking ICU. Display firmware that needs to render international text can use utflite for width calculation while keeping the binary small.</p>

        <p><strong>Game chat systems.</strong> Player names and messages arrive in every language. You need to validate that they're proper UTF-8, count characters for length limits, and measure display width for layout. utflite handles all three without bringing in megabytes of locale data you'll never use.</p>

        <h2>When to Avoid It</h2>

        <p><strong>Text editors.</strong> Users expect the cursor to move by grapheme, not codepoint. An emoji like üë®‚Äçüë©‚Äçüëß (family) is actually seven codepoints joined by ZWJ characters; utflite would treat these as separate units. Use utf8proc or ICU for proper segmentation.</p>

        <p><strong>Search and comparison.</strong> If users might type "na√Øve" with a precomposed √Ø or "na√Øve" with a combining diaeresis, you need normalization to match them. Without it, identical-looking strings won't compare equal.</p>

        <p><strong>Internationalized applications.</strong> Locale-aware sorting, right-to-left languages, complex script shaping (Arabic, Indic scripts)‚Äîthese require full Unicode support. ICU or HarfBuzz is the right tool.</p>

        <h2>Getting Started</h2>

        <p>Integration is deliberately simple. Copy <code>single_include/utflite.h</code> into your project. In one source file:</p>

        <pre><code>#define UTFLITE_IMPLEMENTATION
#include "utflite.h"</code></pre>

        <p>In all other files, include it normally without the define. From there, the API is straightforward: decode, encode, validate, measure width, navigate by character. The header itself serves as documentation, with each function commented.</p>

        <p>For larger projects, utflite also builds as a static library. Clone the repository, run <code>make</code>, and link against <code>libutflite.a</code>. Headers install to <code>/usr/local/include/utflite/</code> with <code>make install</code>.</p>

        <p>The source is on <a href="https://github.com/edwardedmonds/utflite">GitHub</a> under the MIT license. It's small enough to read in one sitting‚Äîwhich, for a library that handles something as subtle as Unicode, is perhaps its greatest feature.</p>

        <footer>
            <p><a href="https://github.com/edwardedmonds/utflite">utflite on GitHub</a> ¬∑ MIT License</p>
        </footer>
    </article>
</body>
</html>
